// ============================================================
// LX32 Control Unit
// ============================================================
// Performs two-level decode:
//   1) Main control (instruction class)
//   2) ALU operation refinement (funct3/funct7)
//
// Design Goals:
//   - Type-safe opcode usage
//   - No implicit latches (Default assignments + Default cases)
//   - Full RV32I ALU coverage
// ============================================================

use crate::models::arch::lx32_alu_pkg::alu_op_e;
use crate::models::arch::lx32_isa_pkg::opcode_t;

/// ControlSignals groups all control lines generated by the decode logic.
/// This acts as the output port of the Control Unit.
#[derive(Debug, Default, PartialEq, Eq)]
pub struct ControlSignals {
    pub reg_write: bool,
    pub alu_src: bool,
    pub mem_write: bool,
    pub result_src: u8, // 2-bit signal: 00=ALU, 01=Mem, 10=PC+4
    pub branch: bool,
    pub alu_control: alu_op_e,
}

/// Internal enumeration for the two-level ALU decoding scheme.
#[derive(PartialEq)]
enum AluMain {
    Add,  // Default for non-ALU instructions (Load/Store)
    Sub,  // Default for Branch comparisons
    Func, // Refine based on funct3/funct7
}

/// LX32 Control Unit - Golden Model
/// Performs instruction decoding to generate control signals.
pub fn control_unit_golden(opcode: opcode_t, funct3: u8, funct7_5: bool) -> ControlSignals {
    let mut sigs = ControlSignals::default();
    let mut alu_op_main = AluMain::Add;

    // ============================================================
    // Main Instruction Decoder
    // ============================================================
    match opcode {
        // Load Instructions
        opcode_t::OP_LOAD => {
            sigs.reg_write = true;
            sigs.alu_src = true;
            sigs.result_src = 0b01;
        }
        // Store Instructions
        opcode_t::OP_STORE => {
            sigs.alu_src = true;
            sigs.mem_write = true;
        }
        // R-Type ALU Instructions
        opcode_t::OP_OP => {
            sigs.reg_write = true;
            alu_op_main = AluMain::Func;
        }
        // I-Type ALU Instructions
        opcode_t::OP_OP_IMM => {
            sigs.reg_write = true;
            sigs.alu_src = true;
            alu_op_main = AluMain::Func;
        }
        // Branch Instructions
        opcode_t::OP_BRANCH => {
            sigs.branch = true;
            alu_op_main = AluMain::Sub;
        }
        // Default: No-op or Invalid
        _ => {}
    }

    // ============================================================
    // ALU Control Decoder (Second Level)
    // ============================================================
    sigs.alu_control = match alu_op_main {
        AluMain::Add => alu_op_e::ALU_ADD,
        AluMain::Sub => alu_op_e::ALU_SUB,
        AluMain::Func => {
            match funct3 {
                // ADD or SUB
                0b000 => {
                    // Only R-Type (OP_OP) with funct7[5] set results in SUB
                    if opcode == opcode_t::OP_OP && funct7_5 {
                        alu_op_e::ALU_SUB
                    } else {
                        alu_op_e::ALU_ADD
                    }
                }
                0b001 => alu_op_e::ALU_SLL,  // Shift Left Logical
                0b010 => alu_op_e::ALU_SLT,  // Set Less Than (signed)
                0b011 => alu_op_e::ALU_SLTU, // Set Less Than (unsigned)
                0b100 => alu_op_e::ALU_XOR,  // Logical XOR
                0b101 => {
                    // SRAI/SRA vs SRLI/SRL (differentiated by funct7_5)
                    if funct7_5 {
                        alu_op_e::ALU_SRA
                    } else {
                        alu_op_e::ALU_SRL
                    }
                }
                0b110 => alu_op_e::ALU_OR,  // Logical OR
                0b111 => alu_op_e::ALU_AND, // Logical AND
                _ => alu_op_e::ALU_ADD,
            }
        }
    };

    sigs
}
