use std::env;
use std::fs;
use std::path::PathBuf;

fn main() {
    // 1. Detect Verilator root smartly:
    //    - Use VERILATOR_ROOT if set
    //    - Otherwise auto-detect by OS
    let verilator_root = env::var("VERILATOR_ROOT").unwrap_or_else(|_| {
        if cfg!(target_os = "macos") {
            // Try all common macOS install locations
            let candidates = [
                "/opt/homebrew/opt/verilator/share/verilator", // Homebrew Apple Silicon
                "/usr/local/opt/verilator/share/verilator",    // Homebrew Intel
                "/opt/local/share/verilator",                  // MacPorts
            ];
            candidates
                .iter()
                .map(PathBuf::from)
                .find(|p| p.exists())
                .map(|p| p.to_string_lossy().to_string())
                .unwrap_or_else(|| {
                    panic!(
                        "Could not find Verilator in common macOS locations. \
                        Install with 'brew install verilator' or set VERILATOR_ROOT"
                    )
                })
        } else {
            // Assume standard location on Linux
            "/usr/share/verilator".to_string()
        }
    });
    let verilator_inc = format!("{}/include", verilator_root);

    // 2. Path to the Verilator-generated files
    let gen_dir = "../../.sim/lx32_lib";

    // 3. Configure the cc build
    let mut builder = cc::Build::new();
    builder
        .cpp(true)
        .warnings(false) // Silence spurious Verilator header warnings
        .file("src/bridge.cpp")
        .file(format!("{}/verilated.cpp", verilator_inc))
        .file(format!("{}/verilated_threads.cpp", verilator_inc))
        .include(gen_dir)
        .include(&verilator_inc)
        .include(format!("{}/vltstd", verilator_inc)); // Standard Verilator std library headers

    // 4. Add all .cpp files generated by Verilator in the simulation dir
    if let Ok(entries) = fs::read_dir(gen_dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if let Some(ext) = path.extension() {
                if ext == "cpp" {
                    println!("cargo:rerun-if-changed={}", path.display());
                    builder.file(path);
                }
            }
        }
    } else {
        panic!(
            "RTL build directory {} not found! Run Verilator first!",
            gen_dir
        );
    }

    // 5. Compile the result as a static library called lx32_bridge
    builder.compile("lx32_bridge");

    // 6. Tell Cargo where to find the compiled static library
    let out_dir = env::var("OUT_DIR").unwrap();
    println!("cargo:rustc-link-search=native={}", out_dir);

    // 7. Tell Cargo to link the bridge static library
    println!("cargo:rustc-link-lib=static=lx32_bridge");

    // 8. Link the proper C++ standard library for your OS
    //    - 'c++' on macOS (libc++.dylib)
    //    - 'stdc++' on Linux (libstdc++.so)
    if cfg!(target_os = "macos") {
        println!("cargo:rustc-link-lib=c++");
    } else if cfg!(target_os = "linux") {
        println!("cargo:rustc-link-lib=stdc++");
    } else {
        // On other platforms, try both (worst case adds an unused search)
        println!("cargo:rustc-link-lib=stdc++");
        println!("cargo:rustc-link-lib=c++");
    }

    // Always re-run if source changes
    println!("cargo:rerun-if-changed=src/bridge.cpp");
}
